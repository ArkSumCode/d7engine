use gl::types::*;

pub mod rect;

/*
a buffer holds the information
used for the attributes of the vertex shader source code

it has an id generated by opengl that points to the graphics card
the target is a value like gl::ARRAY_BUFFER
*/
pub struct Buffer {
    pub id: GLuint,
    target: GLuint,
    usage: GLuint,
}

impl Buffer {
    // create a Buffer Object
    // opengl will generate the id
    pub fn new(target: GLuint, usage: GLuint) -> Self {
        let mut id: GLuint = 0;
        unsafe {
            gl::GenBuffers(1, &mut id);
        }
        Self { id, target, usage }
    }

    // set the buffer to active, 
    // only 1 buffer can be active at a time
    pub fn bind(&self) {
        unsafe {
            gl::BindBuffer(self.target, self.id);
        }
    }

    // give the buffer its data
    // this data is an array of vertices
    // this data describes the attributes of the vertex shader attributes
    pub fn set_data<DataType>(&self, data: &Vec<DataType>) {
        self.bind();
        let size = data.len() * std::mem::size_of::<DataType>();
        let data = data.as_ptr();

        unsafe {
            gl::BufferData(
                self.target,
                size as gl::types::GLsizeiptr,
                data as *const gl::types::GLvoid,
                self.usage
            );
        }
    }
}

impl Default for Buffer {
    // get an empty buffer
    fn default() -> Self {
        Self {
            id: 0,
            target: 0,
            usage: 0,
        }
    }
}

// delete the data from the graphics card
// when the buffer dropps
impl Drop for Buffer {
    fn drop(&mut self) {
        unsafe {
            gl::DeleteBuffers(1, [self.id].as_ptr());
        }
    }
}

/*
A VertexArray is all the data in a single draw call
this can include multiple buffers

it has an id that gets generated by opengl and points to the graphics card
*/
pub struct VertexArray {
    pub id: GLuint,
}

impl VertexArray {
    // generate the id 
    pub fn new() -> Self {
        let mut id: GLuint = 0;
        unsafe {
            gl::GenVertexArrays(1, &mut id);
        }
        Self { id }
    }

    // set the Vertex Array to active 
    // there can only one vertex array be active at a time
    pub fn bind(&self) {
        unsafe {
            gl::BindVertexArray(self.id);
        }
    }
}

impl Default for VertexArray {
    // create an empty vertex array
    fn default() -> Self {
        Self {
            id: 0,
        }
    }
}

// delete the vertex array on the graphics card 
// when VertexArray gets dropped
impl Drop for VertexArray {
    fn drop(&mut self) {
        unsafe {
            gl::DeleteVertexArrays(1, [self.id].as_ptr());
        }
    }
}